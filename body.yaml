    00-auth-config: |
      import json
      import uuid
      from urllib.parse import urlparse, parse_qs
      '''
      A Hub which instantiates a new anonymous session for a user given an image.   The intended use case for this is a Jupyter window in an iframe 
      which contains instructional material.  The image name and the secret for instantiating an image  are passed in as parameters in the URL.
      '''
      from tmpauthenticator import TmpAuthenticator, TmpAuthenticateHandler
      from tornado import web

      # The basics are an extension of TmpAuthenticator and TmpAuthenticatorHandler to check the secret.
      # If the secret is not present or wrong, throw a 403; otherwise mirror the behavior of TmpAuthenticator
      # Also supports choosing an image.

      class TmpSecretAuthenticateHandler(TmpAuthenticateHandler):
        """
        Clone of TmpAuthenticateHandler, except we handle the case where self.login_user returns None.
        For the base class, see: https://github.com/jupyterhub/tmpauthenticator/blob/main/tmpauthenticator/__init__.py
        """

        async def get(self):
          print('In TmpSecretAuthenticateHandler')
          self.clear_login_cookie() # force a new login
          user = await self.login_user(None)
          # This is the only new code from TmpAuthenticatorHandler
          if user is None:
            raise web.HTTPError(403)

          # the rest of the code is TmpAuthenticatorHandler.get
          self.set_hub_cookie(user)

          next_url = self.get_next_url(user)
          self.redirect(next_url)

       
      class TmpSecretAuthenticator(TmpAuthenticator):
        """
        Clone of TmpAuthenticator, except we only start a new session when a secret is passed in, present, and correct.  
        Also add a class which chooses the image based on what is passed in.
        For the base class, see: https://github.com/jupyterhub/tmpauthenticator/blob/main/tmpauthenticator/__init__.py
        """

        def _assign_configuration(self, parm_dict): 
          # Choose an image based on the 'image' parameter passed in in the URL.  parm_dict is a dictionary generated by
          # parse_qs(urlparse.query) where parse_qs and urlparse are both in the standard library urllib.parse
          # the image dictionary and default_image should be in an offboard file.
          configurations = {
            "lesson3": {"image": "gcr.io/ezczstat/lesson3-python:1.0.1", "url": ""},
            "breezing": {"image": "gcr.io/ezczstat/breezing-jlab:1.0.2", "url": "/rstudio"},
            "bayesian-2": {"image": "gcr.io/ezczstat/bayesian-jlab:1.0.2", "url": "/rstudio"},
            "rstudio": {"image": "engagelively/el-jupyter:rstudio2.2.2", "url": "/rstudio"},
            "rstudio-test-iframe": {"image": "engagelively/test-rstudio", "url": "/rstudio"},
            "data_science": {"image": "engagelively/el-jupyter:datascience2.2.2", "url": ""},
            "tensor_flow": {"image": "engagelively/el-jupyter:tensorflow2.2.2", "url": ""},
            "spark": {"image": "engagelively/el-jupyter:allspark2.2.2", "url": ""},
            "base": {"image": "engagelively/el-jupyter:base2.2.2", "url": ""},
            "scipy": {"image": "engagelively/el-jupyter:scipy2.2.2", "url": ""},
            "default": {"image": "quay.io/jupyterhub/singleuser:latest", "url": ""}
          }
         
          # return the selected config if there is one or the default
          selected_config_key = parm_dict['config'][0] if 'config' in parm_dict else "default"
          return configurations[selected_config_key]

        async def authenticate(self, handler, data):
          """
          Authenticate a new user when secret is present in the query string and is identical to my_secret.  
          Note that secret and my_secret should be in an offline, not stored file.
          When secret is present and correct, slways authenticate a new user by generating a universally unique
          identifier (uuid). (Identical to tmp_authenticator)
          """
          
          # New code.  parse the URL and get the query dictionary.

          parsed_url = urlparse(handler.get_next_url())
          parm_dict = parse_qs(parsed_url.query)
          
            
          # Check to see if we should allocate a session.  If so, behavior is identical to TmpAuthenticator

          if 'secret' in parm_dict and parm_dict['secret'][0] == 'my_secret':
            username = str(uuid.uuid4())
            return {
                "name": username,
                "auth_state": {
                  "data": parm_dict,
                  # "configuration": configuration
                }
            }
          else:
            return None


        def get_handlers(self, app):
          """
          Registers a dedicated endpoint and web request handler for logging in
          with TmpAuthenticator. This is needed as /hub/login is reserved for
          redirecting to what's returned by login_url.

          ref: https://github.com/jupyterhub/jupyterhub/pull/1066

          Code is identical to TmpAuthenticator but it uses TmpSecretAuthenticator
          """
          return [("/tmplogin", TmpSecretAuthenticateHandler)]

      # Set the authenticator

      c.JupyterHub.authenticator_class = TmpSecretAuthenticator

      # Logging code which should disappear

      class ProfileAssigner:
        def __init__(self):
          self.profiles = {
            "lesson3": {"image": "gcr.io/ezczstat/lesson3-python:1.0.1", "url": ""},
            "breezing": {"image": "gcr.io/ezczstat/breezing-jlab:1.0.2", "url": "/rstudio"},
            "widgetz": {"image": "gcr.io/ezczstat/widgetz:1.0.2", "url": "/rstudio"},
            "bayesian-2": {"image": "gcr.io/ezczstat/bayesian-jlab:1.0.2", "url": "/rstudio"},
            "rstudio": {"image": "engagelively/el-jupyter:rstudio2.2.2", "url": "/rstudio"},
            "rstudio-test-iframe": {"image": "engagelively/test-rstudio", "url": "/rstudio"},
            "data_science": {"image": "engagelively/el-jupyter:datascience2.2.2", "url": ""},
            "tensor_flow": {"image": "engagelively/el-jupyter:tensorflow2.2.2", "url": ""},
            "spark": {"image": "engagelively/el-jupyter:allspark2.2.2", "url": ""},
            "base": {"image": "engagelively/el-jupyter:base2.2.2", "url": ""},
            "scipy": {"image": "engagelively/el-jupyter:scipy2.2.2", "url": ""},
            "default": {"image": "quay.io/jupyterhub/singleuser:latest", "url": ""}
          }

        def get_profile(self, parm_dict):
          selected_config_key = parm_dict['config'][0] if 'config' in parm_dict else "default"
          return self.choose_profile(selected_config_key)

        def choose_profile(self, profile_name):
          return self.profiles[profile_name] if profile_name in self.profiles else self.profiles['default']
          
      def spawn_get_config_hook(spawner):
        print('In pre-spawn hook')
        profile_chooser = ProfileAssigner()
        profile = profile_chooser.choose_profile('default')
        if spawner is not None:
          if hasattr(spawner, 'handler'):
            print(f'Spawner handler is {type(spawner.handler)}')
            parsed_url = urlparse(spawner.handler.get_next_url())
            parm_dict = parse_qs(parsed_url.query)
            print(json.dumps(parm_dict))
            profile = profile_chooser.get_profile(parm_dict)
          else:
            print('Spawner has no handler')
        print(json.dumps(profile))
        spawner.image = profile["image"]
        spawner.default_url = profile["url"]
        if "cmd" in profile:
          spawner.cmd = profile["cmd"]
        print({"image":spawner.image, "url": spawner.default_url, "cmd": spawner.cmd})
          
      c.Spawner.pre_spawn_hook = spawn_get_config_hook
cull:
  enabled: true
  timeout: 900
  every: 300
  maxAge: 3600
  users: true
singleuser:
  networkPolicy:
    enabled: true
  defaultUrl: "/lab"
  storage:
    type: none
  memory:
    limit: 2G
    guarantee: 100M
  cpu:
    limit: 0.97
    guarantee: 0.002
