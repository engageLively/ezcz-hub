

hub:
  extraConfig:
    00-auth-config: |
      
      import json
      import uuid
      from urllib.parse import urlparse, parse_qs
      '''
      A Hub which instantiates a new anonymous session for a user given an image.   The intended use case for this is a Jupyter window in an iframe 
      which contains instructional material.  The image name and the secret for instantiating an image  are passed in as parameters in the URL.
      '''
      
      
      from tmpauthenticator import TmpAuthenticator, TmpAuthenticateHandler
      from tornado import web

      # The basics are an extension of TmpAuthenticator and TmpAuthenticatorHandler to check the secret.
      # If the secret is not present or wrong, throw a 403; otherwise mirror the behavior of TmpAuthenticator
      # Also supports choosing an image.

      class TmpSecretAuthenticateHandler(TmpAuthenticateHandler):
        """
        Clone of TmpAuthenticateHandler, except we handle the case where self.login_user returns None.
        For the base class, see: https://github.com/jupyterhub/tmpauthenticator/blob/main/tmpauthenticator/__init__.py
        """

        async def get(self):
          user = await self.login_user(None)
          # This is the only new code from TmpAuthenticatorHandler
          if user is None:
            raise web.HTTPError(403)

          # the rest of the code is TmpAuthenticatorHandler.get
          self.set_hub_cookie(user)

          next_url = self.get_next_url(user)
          self.redirect(next_url)

       
      class TmpSecretAuthenticator(TmpAuthenticator):
       """
        Clone of TmpAuthenticator, except we only start a new session when a secret is passed in, present, and correct.  
        Also add a class which chooses the image based on what is passed in.
        For the base class, see: https://github.com/jupyterhub/tmpauthenticator/blob/main/tmpauthenticator/__init__.py
        """

        def _assign_image(self, parm_dict): 
          # Choose an image based on the 'image' parameter passed in in the URL.  parm_dict is a dictionary generated by
          # parse_qs(urlparse.query) where parse_qs and urlparse are both in the standard library urllib.parse
          # the image dictionary and default_image should be in an offboard file.
          images = {
            "rstudio": "engagelively/el-jupyter:rstudio2.2.2",
            "data_science": "engagelively/el-jupyter:datascience2.2.2",
            "tensor_flow": "engagelively/el-jupyter:tensorflow2.2.2",
            "spark": "engagelively/el-jupyter:allspark2.2.2",
            "base": "engagelively/el-jupyter:base2.2.2",
            "scipy": "engagelively/el-jupyter:scipy2.2.2"
          }
          default_image = "engagelively/el-jupyter:datascience2.2.2"
          # return the selected image if there is one or the default
          selected_image = parm_dict['image'][0] if 'image' in parm_dict else default_image
          return selected_image

        async def authenticate(self, handler, data):
          """
          Authenticate a new user when secret is present in the query string and is identical to my_secret.  
          Note that secret and my_secret should be in an offline, not stored file.
          When secret is present and correct, slways authenticate a new user by generating a universally unique
          identifier (uuid). (Identical to tmp_authenticator)
          """
          
          # New code.  parse the URL and get the query dictionary.

          parsed_url = urlparse(handler.get_next_url())
          parm_dict = parse_qs(parsed_url.query)

          # New code.  Set the spawner image to the result of _assign_image (should this be moved elsewhere?)
          c.KubeSpawner.image = self._assign_image(parm_dict)

          # Check to see if we should allocate a session.  If so, behavior is identical to TmpAuthenticator

          if 'secret' in parm_dict and parm_dict['secret'][0] == 'my_secret':
            username = str(uuid.uuid4())
            return {
                "name": username,
                "data": parm_dict
            }
          else:
            return None

        def get_handlers(self, app):
          """
          Registers a dedicated endpoint and web request handler for logging in
          with TmpAuthenticator. This is needed as /hub/login is reserved for
          redirecting to what's returned by login_url.

          ref: https://github.com/jupyterhub/jupyterhub/pull/1066

          Code is identical to TmpAuthenticator but it uses TmpSecretAuthenticator
          """
          return [("/tmplogin", TmpSecretAuthenticator)]

      # Set the authenticator

      c.JupyterHub.authenticator_class = TmpSecretAuthenticator

      # Logging code which should disappear

      def my_hook(authenticator, handler, authentication):
        str = json.dumps(authentication)
        print('In my_hook')
        print(str)
        return authentication
      c.Authenticator.post_auth_hook = my_hook

    